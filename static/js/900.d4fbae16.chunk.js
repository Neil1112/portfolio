"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[900],{6375:function(n,e,r){r.r(e),r.d(e,{codeString:function(){return a},markdownContent:function(){return o}});var t=r.p+"static/media/game.a19007b951c5a7826546.png",o="# Tic Tac Toe - Minimax Algorithm\n\n\nI implemented the Minimax Algorithm to create an unbeatable Tic Tac Toe AI. The Minimax Algorithm is a recursive algorithm which is used to choose an optimal move for a player assuming that the opponent is also playing optimally. It is used in two player games such as Tic Tac Toe, Chess, etc.\n\n![GameImg](".concat(t,")\n\n## Implementation\n"),a="import pygame\nimport sys\nimport copy\nimport random\n\n# Initialize Pygame\npygame.init()\n\n# constants\nWIDTH, HEIGHT = 300, 300\nLINE_COLOR = (128,128,128)\nLINE_WIDTH = 15\nBOARD_ROWS, BOARD_COLS = 3, 3\nSQUARE_SIZE = WIDTH // BOARD_COLS\nCIRCLE_RADIUS = SQUARE_SIZE // 2- 10\nCIRCLE_WIDTH = 15\nX_WIDTH = 25\nX_COLOR = (255,0,0)\nO_COLOR = (0,0,255)\nFONT_SIZE = 36\nAI_MOVE_DELAY = 250 \n\n# Define AI levels and their corresponding random move probabilities\nAI_LEVELS = {\n    'Easy': 0.25,\n    'Medium': 0.5,\n    'Hard': 0.75,\n    'Expert': 1.0\n}\n# Initialize AI level to Medium (0.5 probability)\ncurrent_ai_level = 'Medium'\n\n# COLORS\nWHITE = (255, 255, 255)\nBLACK = (0,0,0)\nWINNER_COLOR = (255, 255, 0)\n\n# Create the game window\nscreen = pygame.display.set_mode((WIDTH, HEIGHT))\npygame.display.set_caption(\"Tic Tac Toe AI\")\n\n# Initialise game variables\nboard = [['' for _ in range(BOARD_COLS)] for _ in range(BOARD_ROWS)]\nplayer_turn = 'X'\ngame_over = False\nwinner = None\n\n# Load font\nfont = pygame.font.Font(None, FONT_SIZE)\n\n\ndef draw_board():\n    screen.fill(BLACK)\n    for row in range(1, BOARD_ROWS):\n        pygame.draw.line(screen, LINE_COLOR, (0, row * SQUARE_SIZE), (WIDTH, row * SQUARE_SIZE), LINE_WIDTH)\n    for col in range(1, BOARD_COLS):\n        pygame.draw.line(screen, LINE_COLOR, (col * SQUARE_SIZE, 0), (col * SQUARE_SIZE, HEIGHT), LINE_WIDTH)\n\n\ndef draw_symbols():\n    for row in range(BOARD_ROWS):\n        for col in range(BOARD_COLS):\n            if board[row][col] == 'X':\n                x_pos = col * SQUARE_SIZE + SQUARE_SIZE // 2\n                y_pos = row * SQUARE_SIZE + SQUARE_SIZE // 2\n                pygame.draw.line(screen, X_COLOR, (x_pos - X_WIDTH, y_pos - X_WIDTH), (x_pos + X_WIDTH, y_pos + X_WIDTH), LINE_WIDTH)\n                pygame.draw.line(screen, X_COLOR, (x_pos - X_WIDTH, y_pos + X_WIDTH), (x_pos + X_WIDTH, y_pos - X_WIDTH), LINE_WIDTH)\n            elif board[row][col] == 'O':\n                x_pos = col * SQUARE_SIZE + SQUARE_SIZE // 2\n                y_pos = row * SQUARE_SIZE + SQUARE_SIZE // 2\n                pygame.draw.circle(screen, O_COLOR, (x_pos, y_pos), CIRCLE_RADIUS, CIRCLE_WIDTH)\n\n\ndef check_win():\n    for row in range(BOARD_ROWS):\n        if board[row][0] == board[row][1] == board[row][2] and board[row][0] != '':\n            return board[row][0]\n    for col in range(BOARD_COLS):\n        if board[0][col] == board[1][col] == board[2][col] and board[0][col] != '':\n            return board[0][col]\n    if board[0][0] == board[1][1] == board[2][2] and board[0][0] != '':\n        return board[0][0]\n    if board[0][2] == board[1][1] == board[2][0] and board[0][2] != '':\n        return board[0][2]\n    return None\n\n\ndef is_board_full():\n    for row in board:\n        for square in row:\n            if square == '':\n                return False\n    return True\n\n\ndef draw_winner(winner):\n    if winner:\n        text = font.render(f\"Player {winner} wins!\", True, WINNER_COLOR)\n        screen.blit(text, (WIDTH // 2 - text.get_width() // 2, HEIGHT // 2 - text.get_height() // 2))\n\n\ndef draw_tie():\n    if not winner and is_board_full():\n        text = font.render(\"It's a tie!\", True, WINNER_COLOR)\n        screen.blit(text, (WIDTH // 2 - text.get_width() // 2, HEIGHT // 2 - text.get_height() // 2))\n\n# Function to restart the game\ndef restart_game():\n    global board, player_turn, game_over, winner\n    board = [['' for _ in range(BOARD_COLS)] for _ in range(BOARD_ROWS)]\n    player_turn = 'X'\n    game_over = False\n    winner = None\n\n\n# minmax AI\ndef minimax(board, depth, is_maximizing):\n    if check_win() == 'O':\n        return 1\n    elif check_win() == 'X':\n        return -1\n    elif is_board_full():\n        return 0\n\n    if is_maximizing:\n        max_eval = -float('inf')\n        for row in range(BOARD_ROWS):\n            for col in range(BOARD_COLS):\n                if board[row][col] == '':\n                    board[row][col] = 'O'\n                    eval = minimax(board, depth + 1, False)\n                    board[row][col] = ''\n                    max_eval = max(max_eval, eval)\n        return max_eval\n    else:\n        min_eval = float('inf')\n        for row in range(BOARD_ROWS):\n            for col in range(BOARD_COLS):\n                if board[row][col] == '':\n                    board[row][col] = 'X'\n                    eval = minimax(board, depth + 1, True)\n                    board[row][col] = ''\n                    min_eval = min(min_eval, eval)\n        return min_eval\n\n# Function to make a random move for the AI - To make it play less optimally\ndef make_random_move():\n    available_moves = [(row, col) for row in range(BOARD_ROWS) for col in range(BOARD_COLS) if board[row][col] == '']\n    if available_moves:\n        return random.choice(available_moves)\n    else:\n        return None\n    \n# Function to display the AI difficulty selection screen\ndef select_ai_difficulty():\n    screen.fill(BLACK)\n\n    title_text = font.render(\"Select AI Difficulty\", True, WHITE)\n    title_text_y = HEIGHT // 8\n    screen.blit(title_text, (WIDTH // 2 - title_text.get_width() // 2, title_text_y))\n\n    options_text = font.render(\"1 - Easy\", True, WHITE)\n    options_text2 = font.render(\"2 - Medium\", True, WHITE)\n    options_text3 = font.render(\"3 - Hard\", True, WHITE)\n    options_text4 = font.render(\"4 - Expert\", True, WHITE)\n\n    # Calculate the vertical positions for each text\n    text_height = options_text.get_height()\n    text_spacing = 10  # Adjust this value to control the spacing between lines\n    y_pos = (HEIGHT - (4 * text_height + 3 * text_spacing)) // 2\n\n    # Blit the text surfaces to the screen with vertical spacing\n    screen.blit(options_text, (WIDTH // 2 - options_text.get_width() // 2, y_pos))\n    y_pos += text_height + text_spacing\n    screen.blit(options_text2, (WIDTH // 2 - options_text2.get_width() // 2, y_pos))\n    y_pos += text_height + text_spacing\n    screen.blit(options_text3, (WIDTH // 2 - options_text3.get_width() // 2, y_pos))\n    y_pos += text_height + text_spacing\n    screen.blit(options_text4, (WIDTH // 2 - options_text4.get_width() // 2, y_pos))\n\n    pygame.display.update()\n\n    while True:\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                pygame.quit()\n                sys.exit()\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_1:\n                    return 'Easy'\n                elif event.key == pygame.K_2:\n                    return 'Medium'\n                elif event.key == pygame.K_3:\n                    return 'Hard'\n                elif event.key == pygame.K_4:\n                    return 'Expert'\n\n# Display AI difficulty selection screen\ncurrent_ai_level = select_ai_difficulty()\n\n\n# Main loop\nwhile True:\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n        \n        # AI's move\n        if not game_over and player_turn == 'O':\n            pygame.time.delay(AI_MOVE_DELAY) \n             # Implement AI level\n            ai_probability = AI_LEVELS[current_ai_level]\n            if random.random() < ai_probability:\n            # Exploitation: Make the best move using the Minimax algorithm\n                best_score = -float('inf')\n                best_move = None\n                for row in range(BOARD_ROWS):\n                    for col in range(BOARD_COLS):\n                        if board[row][col] == '':\n                            board[row][col] = 'O'\n                            score = minimax(board, 0, False)\n                            board[row][col] = ''\n                            if score > best_score:\n                                best_score = score\n                                best_move = (row, col)\n                if best_move:\n                    row, col = best_move\n                    board[row][col] = 'O'\n            else:\n                # Exploration: Make a random move\n                random_move = make_random_move()\n                if random_move:\n                    row, col = random_move\n                    board[row][col] = 'O'\n\n            player_turn = 'X'\n            winner = check_win()\n            if winner or is_board_full():\n                game_over = True\n\n        # Human move\n        if not game_over and player_turn == 'X':\n            if event.type == pygame.MOUSEBUTTONDOWN:\n                x, y = pygame.mouse.get_pos()\n                col = x // SQUARE_SIZE\n                row = y // SQUARE_SIZE\n\n                if board[row][col] == '':\n                    board[row][col] = 'X'\n                    player_turn = 'O'\n                    winner = check_win()\n                    if winner or is_board_full():\n                        game_over = True\n\n        elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:\n            restart_game()\n\n    draw_board()\n    draw_symbols()\n    draw_winner(winner)\n    draw_tie()\n\n    # Display \"Press Space to Restart\" message when the game is over\n    if game_over:\n        restart_text = font.render(\"Press Space to Restart\", True, WINNER_COLOR)\n        screen.blit(restart_text, (WIDTH // 2 - restart_text.get_width() // 2, HEIGHT // 2 + 50))\n    \n    \n    pygame.display.update()\n\n"}}]);
//# sourceMappingURL=900.d4fbae16.chunk.js.map