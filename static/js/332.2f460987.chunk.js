"use strict";(self.webpackChunkportfolio=self.webpackChunkportfolio||[]).push([[332],{9903:function(e,n,a){a.r(n),a.d(n,{codeString:function(){return o},markdownContent:function(){return t}});var i=a.p+"static/media/svd.052f63ab9e64b80fde76.jpg",r=a.p+"static/media/SVD1.8b7870c48ba42f2578a1.png",s=a.p+"static/media/compression.82ee540357091e73842f.png",t="# SVD Image Compression\n\n[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/17IbzCC-dK-7qQinwu07AFMKdZYcEkvDW?usp=sharing)\n\nI applied Singular Value Decomposition (SVD) to compress images. SVD is a matrix factorization technique which can be used to reduce the dimensionality of the data. It is also used for image compression. The SVD decomposes a matrix into 3 matrices. The first matrix contains the left singular vectors, the second matrix contains the singular values and the third matrix contains the right singular vectors. The singular values are the diagonal elements of the second matrix. The singular values are sorted in descending order. The first few singular values contain most of the information about the original matrix. The rest of the singular values contain very little information. We can use this property to compress images. We can keep only the first few singular values and discard the rest. This will reduce the size of the image. We can then reconstruct the image using the first few singular values. The reconstructed image will be very similar to the original image.\n\n![CompressionImg](".concat(s,")\n\n![SVDImg](").concat(i,")\n\n## Image Compression\n\n![SVD1Img](").concat(r,")\n\n\n\n## Implementation of SVD Image Compression in Python using NumPy.\n"),o="import numpy\nfrom PIL import Image\n\n# open the image and return 3 matrices, each corresponding to one channel (R, G and B channels)\ndef openImage(imagePath):\n    imgOrig = Image.open(imagePath)\n    im = numpy.array(imgOrig)\n\n    aRed = im[:, :, 0]\n    aGreen = im[:, :, 1]\n    aBlue = im[:, :, 2]\n\n    return [aRed, aGreen, aBlue, imgOrig]\n\n\n# compress the matrix of a single channel\ndef compressSingleChannel(channelDataMatrix, singularValuesLimit):\n    uChannel, sChannel, vhChannel = numpy.linalg.svd(channelDataMatrix)\n    aChannelCompressed = numpy.zeros((channelDataMatrix.shape[0], channelDataMatrix.shape[1]))\n    k = singularValuesLimit\n\n    leftSide = numpy.matmul(uChannel[:, 0:k], numpy.diag(sChannel)[0:k, 0:k])\n    aChannelCompressedInner = numpy.matmul(leftSide, vhChannel[0:k, :])\n    aChannelCompressed = aChannelCompressedInner.astype('uint8')\n    return aChannelCompressed\n\n# importing image\naRed, aGreen, aBlue, originalImage = openImage('toy.jpg')\n\n# image width and height\nimageWidth = 512\nimageHeight = 512\n\n# number of singular values to use for reconstructing the compressed image\nsingularValuesLimit = 160\n\naRedCompressed = compressSingleChannel(aRed, singularValuesLimit)\naGreenCompressed = compressSingleChannel(aGreen, singularValuesLimit)\naBlueCompressed = compressSingleChannel(aBlue, singularValuesLimit)\n\nimr = Image.fromarray(aRedCompressed, mode=None)\nimg = Image.fromarray(aGreenCompressed, mode=None)\nimb = Image.fromarray(aBlueCompressed, mode=None)\n\nnewImage = Image.merge(\"RGB\", (imr, img, imb))\n\nnewImage.save(\"compressed-toy.jpg\")\n\n# Calculate and display the compression ratio\nmr = imageHeight\nmc = imageWidth\n\noriginalSize = mr * mc * 3\ncompressedSize = singularValuesLimit * (1 + mr + mc) * 3\n\nprint('original size:')\nprint(originalSize)\n\nprint('compressed size:')\nprint(compressedSize)\n\nprint('Ratio compressed size / original size:')\nratio = compressedSize * 1.0 / originalSize\nprint(ratio)\n\nprint('Compressed image size is ' + str(round(ratio * 100, 2)) + '% of the original image ')\n"}}]);
//# sourceMappingURL=332.2f460987.chunk.js.map